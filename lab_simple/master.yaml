clab_name: simple
drawio_diagram: topology.drawio

# Continerlab parameters
clab_startup:
  iosxr:
    image: ios-xr/xrd-control-plane:24.2.11
    kind: cisco_xrd
    startup-config: xrd_initial_cfg.j2
  ios:
    image: vrnetlab/cisco_csr1000v:17.03.08
    kind: cisco_csr1000v
    startup-config: ios_initial_cfg.j2
    env:
      # this is required for correct assignment of mgmt address (otherwise each node gets 10.0.0.15)
      CLAB_MGMT_PASSTHROUGH: true
# Nornir parameters
nornir_startup:
  # note: xrd and xrv9k are equivalent configuration wise -> the same iosxr nornir platform 
  iosxr:
    platform: iosxr
    group: iosxr
    timeout: 60
  ios:
    platform: ios
    group: ios
    timeout: 60
  inventory:
    plugin: SimpleInventory
    options:
      host_file: 'nornir/nornir_hosts.yaml'
      group_file: 'nornir/nornir_groups.yaml'
  runner:
    plugin: threaded
    options:
      num_workers: 10
  logging:
    log_file: nornir/nornir.log

# Parameters specific to each vendor/device type
device_groups:
  iosxr:
    # use default clab credentials (clab/clab@123), because these are baked into xrv9k docker image!
    # - do not define/modify CLAB_MGMT_VRF for the same reason
    username: clab
    password: clab@123
    clab:
      inherit_from: clab_startup.iosxr
    # clab_startup.yaml expects different naming (Gi0-0-0-0) than iosxr (Gi0/0/0/0)
    # - add mapping logic for each clab kind (that requires mapping) in: scripts/utils.py -> clab_intf_map()
    clab_intf_map: True
    nornir:
      inherit_from: nornir_startup.iosxr
    # intf_naming is used for auto-allocation of interface IDs for specific interface type
    intf_naming:
      default:
        name: Gi0/0/0/
        first_id: 0
      core_bundle: 
        name: Bundle-Ether
        first_id: 1
      loopback0:
        name: Loopback
        first_id: 0
    interfaces:
      mgmt:
        name: MgmtEth0/RP0/CPU0/0
  ios:
    username: clab
    password: clab@123
    clab:
      inherit_from: clab_startup.ios
    nornir:
      inherit_from: nornir_startup.ios
    # this is used for auto-allocation of interface IDs
    intf_naming:
      default:
        name: Gi
        first_id: 2
      core_bundle: 
        name: BE
        first_id: 1
      loopback0:
        name: Loopback
        first_id: 0
    interfaces:
      mgmt:
        name: GigabitEthernet1

# Role-specific parameters
# - there could be multiple device types (device_group=iosxr, ios) for the same device role (device_role=pe) 
# - each device could belong to multiple roles (such as rr can also be pce, or p can also be a pe)
# - filename of j2 config templates is composed of device role: 
#   <section><device_role><nornir_platform>.j2   (eg: ibgp_pe_iosxr.j2)
device_roles:
  p:
    device_roles: [p]
  pe:
    device_roles: [pe]
    ibgp:
      asn: 100
      client_of: rr
  cpe:
    device_roles: [cpe]
  rr:
    device_roles: [rr]
    isis:
      ol_bit: True
    ibgp:
      asn: 100
      # TBD: currently this is not handled in iBGP .j2
      full_mesh: [rr]

# List of all devices with inherited vendor-specific (device_groups) and role-specific (device_roles) inventory
devices:
  rr1:
    inherit_from: 
      - device_roles.rr
      - device_groups.iosxr
  rr2:
    inherit_from: 
      - device_roles.rr
      - device_groups.iosxr
  p1:
    inherit_from: 
      - device_roles.p
      - device_groups.iosxr
  p2:
    inherit_from: 
      - device_roles.p
      - device_groups.iosxr
  pe1:
    inherit_from: 
      - device_roles.pe
      - device_groups.iosxr
  pe2:
    inherit_from: 
      - device_roles.pe
      - device_groups.iosxr
  pe3:
    inherit_from: 
      - device_roles.pe
      - device_groups.iosxr
  pe4:
    inherit_from: 
      - device_roles.pe
      - device_groups.iosxr
  cpe1:
    inherit_from: 
      - device_roles.cpe
      - device_groups.ios
  cpe2:
    inherit_from: 
      - device_roles.cpe
      - device_groups.ios
      
# Link-group parameters
link_groups:
  core:
    link_group: core
    prefix: 1.0.0.0/16
    isis: 
      instance: CORE
      metric: 2000
  core_dwdm:
    link_group: core_dwdm
    inherit_from: link_groups.core
    isis: 
      instance: CORE
      metric: 1000
    srte:
      affinity: DWDM
  rr:
    link_group: rr
    inherit_from: link_groups.core
    isis: 
      metric: 99999
  loopback0:
    link_group: loopback0
    prefix: 1.255.0.0/24
  mgmt:
    # If you're starting multiple clabs, you must use different mgmt prefix for each clab instance
    link_group: mgmt
    prefix: 10.255.5.0/24
  access_l3vpn:
    link_group: l3vpn
    prefix: 1.1.0.0/16
    mtu: 1555

# Topology definition
# - Parallel links are allowed
# - Loopback0 and MgmtEth interfaces will be generated by lab_create.py
# - Ensure that all nodes are first defined in "devices:" object
links:
  # TODO: parallel links - need to fix overlap in generated drawio diagram

  # p-p links
  - link: p1---p2
    inherit_from: link_groups.core
  - link: p1---p2
    inherit_from: link_groups.core_dwdm

  # pe-p links
  - link: pe1---p1
    inherit_from: link_groups.core
  - link: pe2---p2
    inherit_from: link_groups.core
  - link: pe3---p1
    inherit_from: link_groups.core
  - link: pe4---p2
    inherit_from: link_groups.core
  - link: pe1---p1
    inherit_from: link_groups.core_dwdm
  - link: pe2---p2
    inherit_from: link_groups.core_dwdm
  - link: pe3---p1
    inherit_from: link_groups.core_dwdm
  - link: pe4---p2
    inherit_from: link_groups.core_dwdm

  # pe-pe links
  - link: pe1---pe2
    inherit_from: link_groups.core
  - link: pe3---pe4
    inherit_from: link_groups.core

  # rr-p links
  - link: rr1---p1
    inherit_from: link_groups.rr
  - link: rr2---p2
    inherit_from: link_groups.rr

  # cpe-pe links
  - link: cpe1---pe1
    inherit_from: link_groups.access_l3vpn
  - link: cpe1---pe2
    inherit_from: link_groups.access_l3vpn
  - link: cpe2---pe3
    inherit_from: link_groups.access_l3vpn
  - link: cpe2---pe4
    inherit_from: link_groups.access_l3vpn

# network services
services:
  l3vpn:
    # Notes:
    # - VRF routes: for demo purposes we'll advertise Loop0 IPs of CPEs
    # - CE-PE uplink (neighbor pe, ifname, ip): derived from "interfaces->lldp->neighbor" in master_complete.yaml:
          # devices:
          #   cpe1:
          #     interfaces:
          #       Gi0/0/0/0:
          #         link_group: l3vpn
          #         lldp:
          #           neighbor: pe1
          #           neighbor_intf: Gi0/0/0/2
          #           neighbor_ipv4: 1.1.0.2/30
    #   -> on CPE we have to configure all (single or multihomed cpe) uplinks to device_role=pe
    #      -> TODO: one could override this by defining intf/neighbor manually in yaml
    # - ASN: 64000 + {{ rd }}
    # - RT/RD: {{ ibgp_asn }}:{{ rd }}

    vrf_A:
      rd: 1001
      affinity_exclude: DWDM
      endpoints:
        # Note: 
        # - cpe1/2 is dual-homed and PE uplinks are determined from infrastructure topology
        # but: if "uplinks" is present, only "uplinks" are used to find the neighbor PEs
        cpe1:
          pe_routing: 
            protocol: ebgp
            asn: 65001
            primary_pe: pe1
        cpe2:
          pe_routing: 
            protocol: static
            primary_pe: pe3